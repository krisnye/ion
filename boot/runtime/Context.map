{"version":3,"sources":["Context.ion"],"names":["ion","Factory","Literal","noop",{"type":"Identifier","name":"noop","loc":{"start":{"line":6,"column":4,"fixed":true,"source":"ion/runtime/Context.ion"},"end":{"line":6,"column":8,"fixed":true,"source":"ion/runtime/Context.ion"}}},"Context","constructor","parent","output","variables","root","_watched","_runtimes","properties","newContext","createRuntime","node","key","toCode","runtime","get","name","variable","getVariable","Error","value","context","global","cachedGlobals","globals","setVariableFromAst","setVariableExpression","setVariableLiteral","expression","watch"],"mappings":"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","sourcesContent":["\nconst\n    ion = import '../'\n    Factory = import './Factory'\n    Literal = import './Literal'\n    noop = ->\n\nexport class Context\n    constructor: (parent, output) ->\n        # the output object that values are written to\n        @output = output\n        # parent is either null or another Context\n        @parent = parent\n        # an object that maps variable names to variable expressions\n        @variables = {}\n        # store a reference to the root context\n        @root = @parent?.root ? @\n        # track which variables we have watched for get property\n        @_watched = {}\n        # runtime nodes keyed by toCode\n        @_runtimes = {}\n    properties:\n        newContext: (output = @output) -> new Context(@, output)\n        createRuntime: (node) ->\n            return Factory.createRuntime(@, node)\n            if not node?\n                return null\n            let key = Factory.toCode(node)\n            let runtime = @_runtimes[key]\n            if not runtime?\n                runtime = @_runtimes[key] = Factory.createRuntime(@, node)\n            return runtime\n        get: (name) ->\n            let variable = @getVariable(name)\n            if not variable?\n                throw new Error(\"Variable not found: '{{name}}'\")\n            return variable.value\n        getVariable: (name) ->\n            let context = @, value\n            while context?\n                let variable = context.variables[name]\n                if variable?\n                    return variable\n                context = context.parent\n            # if the variable is not defined by us then it is probably a global variable.\n            # we do however require that it be a globally defined variable, otherwise we throw an error.\n            value = global[name]\n            if value is undefined\n                throw new Error(\"Variable not found: '{{name}}'\")\n            # global values are considered to be constants.\n            # we could consider caching these values within the context.\n            let cachedGlobals = @root.globals ?= {}\n            return cachedGlobals[name] ?= new Literal({value})\n        setVariableFromAst: (name, node) ->\n            if name?\n                @setVariableExpression(name, @createRuntime(node))\n        setVariableLiteral: (name, value) ->\n            if name?\n                @setVariableExpression(name, new Literal({value}))\n        setVariableExpression: (name, expression) ->\n            if name?\n                # we always watch the expression to make sure it is created only once\n                # if we don't, then it may be created and destroyed multiple times which can cause bugs\n                expression.watch(noop)\n                return @variables[name] = expression\n"]}