{

    const ast = require("./ast")
    // const types = require("./types")
    const pathSeparator = "/"

    function getLocation() {
        let { start, end, filename } = location()
        return new ast.Location({
            start: new ast.Position(start.offset, start.line, start.column),
            end: new ast.Position(end.offset, end.line, end.column),
            filename
        })
    }

    function getEmptyLocation() {
        let { start, end, filename } = location()
        return new ast.Location({
            start: new ast.Position(start.offset, start.line, start.column),
            end: new ast.Position(start.offset, start.line, start.column),
            filename
        })
    }

    function isUpperCase(name) {
        let first = name[0]
        return first === first.toUpperCase()
    }

    function isTypeName(name) {
        return isUpperCase(name)
    }

    function getRelativePrefixSteps(relative) {
        if (relative === 0) {
            return []
        }
        if (relative == 1) {
            return ["."]
        }
        return new Array(relative - 1).fill("..")
    }

    function node(type, ...values) {
        // we assign again in case it was overridden by copy values
        let TypeConstructor = ast[type]
        if (TypeConstructor == null) {
            throw new Error("Missing Type: " + type)
        }
        let result = new TypeConstructor(Object.assign({ location: getLocation() }, ...values))
        return result
    }

    function operation(left, operator, right, props) {
        if (right) {
            return node("BinaryExpression", { left, operator, right, ...props })
        }
        else {
            // if the right is a Literal, then we return a literal, NOT a unary expression.
            if (ast.Literal.is(left) && typeof left.value === "number") {
                if (operator === "-") {
                    return node("Literal", { ...left, value: - left.value })
                }
            }
            return node("UnaryExpression", { operator, argument:left, ...props })
        }
    }

    function buildBinaryExpression(head, tail) {
        return tail.reduce(
            (left, huh) => {
                let [,operator,,right] = huh;
                return operation(left, operator, right)
            }
            ,head
        )
    }

    function toMap(nodes, getKey = node => node.id.name) {
        return new Map(nodes.map(node => [getKey(node), node]))
    }

    function toChain(head, tail) {
        return tail.reduce(
            (left, right) => {
                if (right.arguments) {
                    return node("Call", {callee:left, ...right})
                }
                else {
                    return node("MemberExpression", { object:left, ...right })
                }
            }
            ,head
        )
    }

    function isValidId(name) {
        return (/^[a-z_$][a-z_$0-9]*$/i).test(name)
    }

    function buildTemplateLiteral(sections) {
        let quasis = []
        let expressions = []
        let wasPreviousExpression = true
        let maybePushEmptyQuasi = () => {
            if (wasPreviousExpression) {
                quasis.push(node("TemplateElement", { location: getEmptyLocation() }))
            }
        }
        for (let section of sections) {
            if (ast.Expression.is(section)) {
                maybePushEmptyQuasi()
                expressions.push(section)
                wasPreviousExpression = true
            }
            else {
                if (!wasPreviousExpression && quasis.length > 0) {
                    // we need to merge quasis.
                    let last = quasis[quasis.length - 1]
                    quasis[quasis.length - 1] = last.patch({
                        location: new ast.Location({
                            start: last.location.start,
                            end: section.location.end,
                            filename: last.location.filename,
                        }),
                        valueRaw: last.valueRaw + section.valueRaw,
                        valueCooked: last.valueCooked + section.valueCooked,
                    })
                }
                else {
                    quasis.push(section)
                }
                wasPreviousExpression = false
            }
        }
        maybePushEmptyQuasi()
        quasis[quasis.length - 1] = quasis[quasis.length - 1].patch({ tail: true })
        return node("TemplateLiteral", { quasis, expressions })    
    }

}

////////////////////////////////////////////////////////////////////////////////
//  Module
////////////////////////////////////////////////////////////////////////////////

Module
    = EOL? body:Statement* EOL EOF
    { return node("Module", { body: body.flat() }) }

////////////////////////////////////////////////////////////////////////////////
//  Statements
////////////////////////////////////////////////////////////////////////////////

Statement
    = For
    / Conditional
    / Return
    / ClassDeclaration
    / OutlineExpression

OutlineVariableDeclaration
    = meta:MetaProperties? id:Pattern type:(_ ":" _ @InlineType) value:((_ "=" _ @OutlineExpression) / EOL { return null})
    { return node("Variable", { id, meta, type, value }) }
    / meta:MetaProperties? id:Pattern type:(_ ":" _ @InlineType)? value:(_ "=" _ @OutlineExpression)
    {
        if (ast.Identifier.is(id) && isTypeName(id.name)) {
            value = node("TypeExpression", { location: value.location, value })
        }
        return node("Variable", { id, meta, type, value })
    }

InlineVariableDeclaration
    = id:Declarator type:(_ ":" _ @InlineType) value:((_ "=" _ @InlineExpression) { return null})
    { return node("Variable", { id, type, value }) }
    / id:Declarator type:(_ ":" _ @InlineType)? value:(_ "=" _ @InlineExpression)
    {
        if (ast.Identifier.is(id) && isTypeName(id.name)) {
            value = node("TypeExpression", { location: value.location, value })
        }
        return node("Variable", { id, type, value })
    }

OutlineAssignment
    = left:Reference _ operator:":=" _ right:OutlineExpression
    { return node("Assignment", { left, operator, right }) }

InlineAssignment
    = left:Reference _ operator:":=" _ right:InlineExpression
    { return node("Assignment", { left, operator, right }) }

Conditional
    = IfToken _ test:InlineExpression consequent:Block
        alternate:(Dent ElseToken _ @(Block / Conditional))?
    { return node("Conditional", { test, consequent, alternate }) }

Block
    = EOL Indent body:(Dent @Statement)+ Outdent
    {
        body = body.flat()
        return node("Block", { body })
    }

////////////////////////////////////////////////////////////////////////////////
//  Functions                                                                 //
////////////////////////////////////////////////////////////////////////////////

Parameter
    = meta:MetaProperties? id:Declarator _ type:(":" _ @InlineExpression)? _ value:("=" _ @InlineExpression)?
    { return node("Variable", { id, meta, type, value })}

InlineFunctionParameters
    = "(" _ ")" { return [] }
    / "(" _ head:Parameter tail:(_ ',' _ @Parameter)* _ ")" { return [head, ...tail] }

InlineFunctionParametersAndType
    = id:Identifier? parameters:InlineFunctionParameters returnType:(_ ":" _ @InlineExpression)? _ "->"
    { return { id, parameters, returnType } }

OutlineFunctionParametersAndType
    = InlineFunctionParametersAndType
    / id:Identifier? "()" returnType:(_ ":" _ @InlineExpression)? EOL Indent parameters:(Dent @Parameter EOL)+ Outdent Dent "->"
    { return { id, parameters, returnType } }

InlineBlock
    = value:InlineExpression
    { return node("Block", { body: [value] }) }

OutlineFunction
    = head:OutlineFunctionParametersAndType _ body:(Block / (@InlineBlock EOL))
    { return node("FunctionExpression", { ...head, body }) }

InlineFunction
    = head:InlineFunctionParametersAndType _ body:InlineBlock
    { return node("FunctionExpression", { ...head, body }) }

// do classes next, and at least placeholders for generics.

////////////////////////////////////////////////////////////////////////////////
//  OLD ------------------->
////////////////////////////////////////////////////////////////////////////////

DebuggerStatement
    = "debugger" EOL
    { return node("DebuggerStatement") }

SwitchStatement
    = SwitchToken _ discriminant:InlineExpression EOL
        Indent
            cases: (Dent @SwitchCase)+
        Outdent
    { return node("SwitchStatement", { discriminant, cases: cases.flat() }) }

SwitchTest
    = DefaultToken { return null }
    / InlineExpression

SwitchCase
    = head:SwitchTest tail:(_ "," _ @SwitchTest)* ":" _
        consequent: (value:Statement {return node("Block", { body: Array.isArray(value) ? value : [value]}) } / Block)
    {
        let tests = [head, ...tail]
        return tests.map((test, index) => node("SwitchCase", { test, consequent: index === tests.length - 1 ? consequent : null }))
    }


VariableModifiers
    = &StaticToken id:Identifier _ { return { static: id } }
    / &. { return {} }

AbstractModifier
    = &AbstractToken id:Identifier _ { return { /* abstract: id */ } }

PropertyModifiers
    = AbstractModifier
    / VariableModifiers

MetaProperties
 = (@DynamicOutlineProperty Dent)*

DynamicOutlineProperty
    = '[' _ key:InlineExpression _ ']' value:(_ "=" _ @OutlineExpression / EOL { return null })
    { return node("Property", {key, value} ) }

// VariableMetaProperties
//     = EOL Indent @OutlineProperty+ Outdent

AssignmentOperator
    = "="
    / "+="
    / "-="
    / "*="
    / "%="
    / "**="
    / "/="
    / "^="
    / ">>="
    / "<<="
    / ">>>="
    / "<<<="
    / "&="
    / "&&="
    / "|="
    / "||="
    / "??="

For
    = ForToken _ left:Declarator _ count:("," _ @Declarator _)? InToken _ right:InlineExpression body:Block
    {
        return node("For", {
            left: (node("Variable", { id: left })),
            count: count ? (node("Variable", { id: count })) : null,
            right, body
        })
    }

While
    = WhileToken _ test:InlineExpression body:Block
    { return node("While", { test, body }) }

Return
    = ReturnToken _ value:OutlineExpression
    { return node("Return", { value }) }
    / ReturnToken _ value:InlineExpression? EOL
    { return node("Return", { value: value || null }) }

Break
    = BreakToken EOL
    { return node("Break", {}) }

ContinueStatement
    = ContinueToken EOL
    { return node("ContinueStatement", {}) }

////////////////////////////////////////////////////////////////////////////////
//  Patterns
////////////////////////////////////////////////////////////////////////////////

Pattern
    = Declarator
    / ArrayPattern
    / ObjectPattern
    / RestElement

ArrayPattern
    = "[" _ element:RestElement _ "]"
    { return node("ArrayPattern", { elements: [element] }) }
    / "[" _ head:Pattern? tail:(_ "," _ !"." @Pattern?)* rest:(_ "," _ @RestElement)? _ "]"
    {
        let elements = [head || null, ...tail.map((x) => x || null)]
        if (rest) {
            elements.push(rest)
        }
        return node("ArrayPattern", { elements })
    }

RestElement
    = "..." value:Declarator
    { return node("RestElement", { value }) }

ObjectPattern
    = "{" _ head:AssignmentProperty tail:(_ "," _ @AssignmentProperty)* rest:(_ "," _ @RestElement)? _ "}"
    {
        let properties = [head, ...tail]
        if (rest) {
            properties.push(rest)
        }
        return node("ObjectPattern", { properties })
    }

AssignmentProperty
    = key:Identifier value:(_ ":" _ @Pattern / _ "=" _ @InlineExpression)?
    {
        if (ast.Expression.is(value)) {
            // AssignmentPattern
            return node("Property", { key, value: node("AssignmentPattern", { left: node("Declarator", key), right: value })})
        }
        return node("Property", { key, value: value || node("Reference", key), shorthand: value == null } )
    }

////////////////////////////////////////////////////////////////////////////////
//  Enums and Flags
////////////////////////////////////////////////////////////////////////////////

EnumProperty
    = Dent key:Identifier _ "=" _ value:OutlineExpression
    { return node("Property", { key, value })}

EnumDeclaration
    = EnumToken _ id:Declarator EOL Indent properties:EnumProperty+ Outdent
    { return node("EnumDeclaration", { id, properties }) }

////////////////////////////////////////////////////////////////////////////////
//  Class
////////////////////////////////////////////////////////////////////////////////

ClassType
    = ClassToken { return {} }
    / StructToken { return { isStruct: true } }

ClassDeclaration
    = meta:MetaProperties
        type:ClassType
        _ id:Declarator typeParameters:TemplateParameters? _ baseClasses:Extends? EOL
        Indent
            declarations:(Dent @(OutlineVariableDeclaration))*
        Outdent
        {
            return node("ClassDeclaration", {
                id, ...type, typeParameters: typeParameters || [], baseClasses: baseClasses || [],
                declarations,
                meta: meta || null,
            })
        }

TemplateParameters
    = "<" _ head:Parameter tail:(_ ',' _ @Parameter)* _ ">" { return [head, ...tail] }

Extends
    = ExtendsToken _ head:Reference tail:(_ "," _ @Reference)*
    { return [head, ...tail] }

Implements
    = ImplementsToken _ head:Reference tail:(_ "," _ @Reference)*
    { return [head, ...tail] }

////////////////////////////////////////////////////////////////////////////////
//  TypeExpression
////////////////////////////////////////////////////////////////////////////////

OutlineType
    = @InlineType EOL

InlineType
    = type:InlineExpression
    {
        return ast.Reference.is(type) ? type : node("TypeExpression", { value: type })
    }

FunctionType
    = parameters:InlineFunctionParameters _ "=>" _ returnType:InlineType
    { return node("FunctionType", { parameters, returnType }) }
    / "(" _ @FunctionType _ ")"

TemplateArguments
    = "<" _ head:InlineExpression tail:(_ "," _ @InlineExpression)*  _ ">"
    { return [head, ...tail] }

////////////////////////////////////////////////////////////////////////////////
//  Operations
////////////////////////////////////////////////////////////////////////////////

UpdateOperator
    = "++" / "--"

UpdateExpression
    = operator:UpdateOperator argument:MemberExpression
    { return operation(argument, operator, null, { prefix: true  }) }
    / argument:MemberExpression operator:UpdateOperator?
    { return operator ? operation(argument, operator, null, { prefix: false }) : argument }

UnaryOperator
    = "+" / "-" / "!" / TypeofToken / DeleteToken

UnaryExpression
    = operator:(@UnaryOperator _)? argument:UpdateExpression
    { return operator ? operation(argument, operator) : argument }

ExponentiationOperator "operator"
    = "**" / "<<" / ">>>" / ">>"

ExponentiationExpression
    = left:UnaryExpression right:(_ operator:ExponentiationOperator _ right:ExponentiationExpression {return {operator,right}})?
    { return right ? node("BinaryExpression", {left, operator:right.operator, right:right.right}) : left }

MultiplicativeOperator
    = "*" / "/" / "%"

MultiplicativeExpression
    = head:ExponentiationExpression tail:(_ MultiplicativeOperator _ ExponentiationExpression)*
    { return buildBinaryExpression(head, tail) }

AdditiveOperator
    = "+" / "-"

AdditiveExpression
    = head:MultiplicativeExpression tail:(_ AdditiveOperator _ MultiplicativeExpression)*
    { return buildBinaryExpression(head, tail) }

RelationalOperator
    = "<=" / ">=" / "<" / ">" / IsntToken / IsToken

RelationalExpression
    = head:AdditiveExpression tail:(_ RelationalOperator _ AdditiveExpression)*
        { return buildBinaryExpression(head, tail) }
    // don't remove the initial _ below. It is necessary to match tail above layout
    / tail:(_ RelationalOperator _ AdditiveExpression)
        { return buildBinaryExpression(node('DotExpression') , [tail]) }

EqualityOperator
    = "==" / "!="

EqualityExpression
    = head:RelationalExpression tail:(_ EqualityOperator _ RelationalExpression)*
        { return buildBinaryExpression(head, tail) }

BitwiseAndOperator
    = "&"

BitwiseAndExpression
    = head:EqualityExpression tail:(_ BitwiseAndOperator _ EqualityExpression)*
    { return buildBinaryExpression(head, tail) }

BitwiseXorOperator
    = "^"

BitwiseXorExpression
    = head:BitwiseAndExpression tail:(_ BitwiseXorOperator _ BitwiseAndExpression)*
    { return buildBinaryExpression(head, tail) }

BitwiseOrOperator
    = "|"

BitwiseOrExpression
    = head:BitwiseXorExpression tail:(_ BitwiseOrOperator _ BitwiseXorExpression)*
    { return buildBinaryExpression(head, tail) }

LogicalAndOperator
    = "&&"

LogicalAndExpression
    = head:BitwiseOrExpression tail:(_ LogicalAndOperator _ BitwiseOrExpression)*
    { return buildBinaryExpression(head, tail) }

LogicalOrOperator
    = "||" / "??" / XorToken

LogicalOrExpression
    = head:LogicalAndExpression tail:(_ LogicalOrOperator _ LogicalAndExpression)*
    { return buildBinaryExpression(head, tail) }

ConditionalOperator
    = "?"

ConditionalExpression
    = test:LogicalOrExpression
        body:(
            _ ConditionalOperator _ consequent:ConditionalExpression
            _ ':' _ alternate:ConditionalExpression
            { return {consequent,alternate} }
        )?
    { return body ? node('ConditionalExpression', { test, ...body }) : test }

// AssignmentExpression
//     = head:ConditionalExpression tail:(_ AssignmentOperator _ AssignmentExpression)?
//     {
//         let [,op,,right] = tail
//         return tail ? node("AssignmentExpression", { left: head, operator, right }) : head
//     }

RangeOperator
    = "..." { return true }
    / ".." { return false }

RangeExpression
    = start:ConditionalExpression _ inclusive:RangeOperator _ end:ConditionalExpression step:(_ ByToken _ @ConditionalExpression)?
    { return node("Range", { start, end, inclusive, step: step || null }) }

////////////////////////////////////////////////////////////////////////////////
//  Expressions
////////////////////////////////////////////////////////////////////////////////

OutlineExpression
    = OutlineMemberExpression
    / EOL Indent Dent @OutlineMemberExpression Outdent

OutlineExpressionStartsThisLine
    = OutlineAssignment
    / OutlineVariableDeclaration
    / OutlineDoExpression // must be higher precedence than OutlineFunction
    / OutlineFunction
    / OutlineArrayExpression
    / OutlineObjectExpression
    / OutlineJSXElementExpression
    // / OutlineMapExpression
    / OutlineCallExpression
    // / OutlineNewExpression
    / OutlineStringLiteral
    / OutlineTemplateLiteral
    / OutlineSpreadElement
    / OutlineOperation
    / @InlineExpression EOL

OutlineMemberExpression =
    head:OutlineExpressionStartsThisLine
    tail:(Dent @OutlineChain)*
    {
        // we flatten and remove arrays since trailing comments show up as arrays.
        tail = tail.flat().filter(a => !Array.isArray(a))
        return toChain(head, tail)
    }

OutlineDoExpression
    = DoToken " " _ callee:OutlineFunction
    { return node("Call", { callee, arguments: [] }) }

OutlineDoStatement
    = DoToken @Block

OutlineOperation
    =
        operator:("+" / "-" / "||" / "&&" / "|" / "&" / "**" / "*" / "/")
        operands:OutlineArguments
    {
        if (operands.length === 2 && operands.every(ast.Expression.is)) {
            return node("BinaryExpression", { left: operands[0], operator, right: operands[1] })
        }
        return node("OutlineOperation", { operator, body:operands })
    }

OutlineArguments
    = EOL Indent args:(Dent @(DebuggerStatement / OutlineExpression / Statement))+ Outdent
    { return args.flat() }

OutlineCallExpression
    = call:InlineExpression args:OutlineArrayArguments
    & { return ast.Call.is(call) }
    { return node("Call", { ...call, arguments: [...call.arguments, ...args] }) }

// OutlineNewExpression
//     = NewToken _ callee:MemberExpressionNoCall args:(@InlineArguments EOL / OutlineArguments)
//     { return node("Call", { new: true, callee, arguments: args }) }

InlineExpression
    = InlineSpreadElement
    / InlineFunction
    / InlineAssignment
    / RangeExpression
    / ConditionalExpression
    / InlineVariableDeclaration

InlineNewExpression
    = NewToken _ callee:MemberExpressionNoCall args:InlineArguments
    { return node("Call", { new: true, callee, arguments: args }) }

PrimaryExpression
    = Reference
    / Literal
    // / ThisExpression
    / DotExpression
    / AnonymousCall
    / InlineNewExpression
    / InlineArrayExpression
    / InlineObjectExpression
    / InlineJSXElementExpression
    // / InlineMapExpression

AnonymousCall
    = "()"
    { return node('Call', { arguments: [] })}
    / "(" _ arguments:InlineExpressionList _ ")"
    { return arguments.length == 0 ? arguments[0] : node('Call', { arguments })}

// ThisExpression
//     = ThisToken { return node('ThisExpression') }

DotExpression
    = "." property:Identifier
    { return node('MemberExpression',{object:node('DotExpression'),property,computed:false}) }
    / ".[" _ property:InlineExpression _ "]"
    { return node('MemberExpression',{object:node('DotExpression'),property,computed:true}) }
    / "."
    { return node('DotExpression') }

InlineExpressionList
    = head:InlineExpression tail:(_ "," _ @InlineExpression)*
    { return [head, ...tail] }

InlineArguments
    = "()" { return [] }
    / "(" _ @InlineArgumentList _ ")"

InlineChainMemberComputed
    = optional:"?"? "[" _ property:InlineExpression _ "]"
    { return { property, computed:true, optional: optional != null } }

InlineChainMember
    = optional:"?"? _ "." property:Identifier
    { return { property, computed:false, optional: optional != null } }

InlineChainMemberCall
    = optional:"?"? args:InlineArguments
    { return { arguments:args, optional: optional != null } }

InlineChain
    = InlineChainMemberComputed
    / InlineChainMember
    / InlineChainMemberCall

OutlineChainStart
    = InlineChainMember
    / "." @(InlineChainMemberComputed / InlineChainMemberCall)

OutlineChainHead
    = head:OutlineChainStart tail:InlineChain*
    { return [head, ...tail] }

OutlineChain
    = head:OutlineChainHead tail:(OutlineArguments / EOL { return null })
    {
        let last = head[head.length - 1]
        if (tail && last.arguments) {
            // then we can insert our outline arguments if we have any.
            head[head.length - 1] = { ...last, arguments: [...last.arguments, ...tail] }
        }
        return head
    }

MemberExpression =
    head: PrimaryExpression
    tail: InlineChain*
    { return toChain(head, tail) }

MemberExpressionNoCall =
    head: PrimaryExpression
    tail: (InlineChainMemberComputed / InlineChainMember)*
    {
        return tail.reduce(
            (left, right) => node("MemberExpression", { object:left, ...right })
            ,head
        )
    }

////////////////////////////////////////////////////////////////////////////////
//  Literals
////////////////////////////////////////////////////////////////////////////////

InlineSpreadElement
    = "..." argument:InlineExpression
    { return node("Spread", { argument }) }

OutlineSpreadElement
    = "..." argument:OutlineExpression
    { return node("Spread", { argument }) }

ArrayElement
    = InlineSpreadElement
    / InlineExpression

ArrayElements
    = head:ArrayElement tail:(_ "," _ @ArrayElement)*
    { return [head, ...tail] }

InlineArrayExpression
    = "[" _ body:ArrayElements? _ "]"
    { return node("ArrayExpression", { body:body || [] }) }
    // / "|" _ body:ArrayElements? _ "|"
    // { return node("ArrayExpression", { body:body || [], isSet: true }) }

////////////////////////////////////////////////////////////////////////////////
//  JSX @see https://facebook.github.io/jsx/
////////////////////////////////////////////////////////////////////////////////

JSXAttributeName
    = InlineStringLiteral
    / JSXIdentifierOrLiteral

JSXIdentifierOrLiteral
    = [@a-zA-Z$_0-9\-]+ !"."
    {
        let name = text()
        return isValidId(name) ? node("Identifier", { name } ) : node("Literal", { value: name })
    }

JSXElementName
    = value:JSXIdentifierOrLiteral
    { return ast.Identifier.is(value) ? new ast.Reference(value) : value }
    / object:Reference property:( "." @Identifier)?
    { return property ? node("MemberExpression", { object, property }) : object }

JSXAttribute
    = key:JSXAttributeName value:JSXAttributeInitializer?
    { return node("Property", { key, value: value || node("Literal", { value: true }) }) }

JSXAttributeInitializer
    = "=" _ @JSXAttributeValue

JSXAttributeValue
    = InlineStringLiteral
    / "{" _ @InlineExpression _ "}"

JSXSpreadAttribute
    = "{" _ @InlineSpreadElement _ "}"

JSXAttributes
    = (_ @(JSXAttribute / JSXSpreadAttribute))+

InlineJSXElementSelfClosing
    = "<" _ kind:JSXElementName _ properties:JSXAttributes? _ "/>"
    { return node("ElementExpression", { kind, properties: properties || [], children: [] }) }

InlineJSXElementOpen
    = "<" _ kind:JSXElementName _ properties:JSXAttributes? _ ">"
    { return node("ElementExpression", { kind, properties: properties || [], children: [] }) }

InlineJSXElementClose
    = "</" _ @JSXElementName _ ">"

InlineJSXText
    = ( !"<" !">" !"{" !"}" .)+
    { return node("Literal", { value: text().replace(/&lt;/g, "<").replace(/&gt;/g, ">") })}

InlineJSXChild
    = "{" _ @(InlineExpression / InlineSpreadElement) _ "}"
    / InlineJSXElementExpression
    / InlineJSXText

InlineJSXElementExpression
    = InlineJSXElementSelfClosing
    / open:InlineJSXElementOpen children:InlineJSXChild* close:InlineJSXElementClose
    { return node("ElementExpression", { ...open, children, close: close || null }) }

OutlineJSXElementExpression
    = element:InlineJSXElementSelfClosing children:OutlineArrayArguments
    { return node("ElementExpression", { ...element, children }) }

// how can you tell an outline named argument from a variable?
InlineArgument
    = id:(@Identifier _ ":" _)? value:InlineExpression
    { return node("Argument", { id: id || null, value }) }

InlineArgumentList
    = head:InlineArgument tail:(_ "," _ @InlineArgument)*
    { return [head, ...tail] }

OutlineArrayArguments
    = EOL Indent args:(Dent @(OutlineExpression / @InlineExpressionList EOL / @Statement))+ Outdent
    { return args.flat() }

OutlineArrayExpression
    = "[]" body: OutlineArrayArguments
    { return node("ArrayExpression", { body: body.flat() }) }

OutlineObjectExpression
    = e:InlineObjectExpression body:OutlinePropertyList
    { return node("ObjectExpression", { isMap: e.isMap, body: [...e.body, ...body] }) }

// OutlineMapExpression
//     = e:InlineMapExpression properties:OutlineMapPropertyList
//     { return node("MapExpression", {properties: [...e.properties, ...properties] }) }

// OutlineMapPropertyList
//     = EOL Indent @(Dent @(OutlineMapProperty / Statement))+ Outdent

// OutlineMapProperty
//     = key:InlineExpression _ ":" _ value:OutlineExpression
//     { return node("Property", { key, value, computed: true })}

OutlinePropertyList
    = EOL Indent @(Dent @(OutlineProperty / Statement))+ Outdent

PropertyStatement
    = OutlineProperty
    // / OutlineMapProperty
    // { return node("PropertyStatement", { property }) }

OutlineProperty
    = @InlineSpreadElement EOL
    / "[" _ key:InlineExpression _ "]" _ ":" _ value: OutlineExpression
    { return node("Property", { key, value, computed: true }) }
    / key:(@(Identifier / InlineStringLiteral) _ ":") _ value:OutlineExpression
    { return node("Property", { key, value }) }
    / key:Identifier EOL
    { return node("Property", { key, value: node("Reference", key), shorthand: true }) }
    //  don't support inline lists on outline objects... it's harder to see specific
    // / @InlinePropertyList EOL

InlineMapProperty
    = key:InlineExpression _ ":" _ value:InlineExpression
    { return node("Property", { key, value, computed: true })}

InlineMapPropertyList
    = head:InlineMapProperty tail:(_ "," _ @InlineMapProperty)*
    { return [head, ...tail] }

InlineObjectExpression
    = "{" _ body:InlinePropertyList? _ "}"
    { return node("ObjectExpression", { body: body || []}) }
    // / "(" _ properties:InlineMapPropertyList? _ ")"
    // { return node("ObjectExpression", { properties: properties || [], isMap: true }) }

InlineProperty
    = InlineSpreadElement
    / "[" _ key:InlineExpression _ "]" _ "=" _ value: InlineExpression
    { return node("Property", { key, value }) }
    / key:(@(Identifier / InlineStringLiteral) _ "=") _ value:InlineExpression
    { return node("Property", { key, value }) }
    / key:Identifier
    { return node("Property", { key, value: node("Reference", key), shorthand: true }) }

InlinePropertyList
    = head:InlineProperty tail:(_ "," _ @InlineProperty)*
    { return [head, ...tail] }

Literal
    = NumericLiteral
    // / BooleanLiteral
    / InlineStringLiteral
    / InlineTemplateStringLiteral
    / NullLiteral
    / RegularExpression

NumericLiteral
    = HexIntegerLiteral
    / DecimalLiteral
    / DecimalIntegerLiteral

NullLiteral
    = NullToken { return node('Literal', { value: null }) }

// BooleanLiteral
//     = value: (TrueToken / FalseToken) { return node('Literal', { value: JSON.parse(value) ? true : false } ) }

ExponentPart
    = 'e' [+-]? [0-9]+ !IdPart

DecimalLiteral
    = (DecimalInteger? '.' [0-9]+ ExponentPart? / DecimalInteger ExponentPart) !IdPart
    { return node('Literal', { value: parseFloat(text()), type: node('Reference', { name: 'Number'}) })}

HexDigit
    = [0-9A-Fa-f]

HexIntegerLiteral
    = '0x' HexDigit+ !IdPart { return node('Literal', {value: parseInt(text(), 16), type: node('Reference', { name: 'Number'}) }) }

DecimalIntegerLiteral
    = DecimalInteger { return node('Literal', { value: parseInt(text()), type: node('Reference', { name: 'Number'}) }) }

DecimalInteger
    = '0' / [+-]? [1-9] [0-9]* !IdPart { return parseInt(text()) }

InlineStringLiteral
    = '"' DoubleStringChar* '"' { return node('Literal', { value: eval(text()), type: node('Reference', { name: 'String'}) }); }

DoubleStringChar
    = "\\\"" / !'"' .
    // = [^\r\n\t\b\f"] / "\\" ([rn"\\] / "u" HexDigit<4>)

InlineTemplateStringLiteral
    = "`" sections:(InlineTemplateExpression / InlineTemplateElement)* "`"
    { return buildTemplateLiteral(sections) }

InlineTemplateExpression
    = "${" _ @InlineExpression _ "}"

InlineTemplateElement
    = (!("${" / LineTerminatorSequence) ("\\`" / !"`" .))+ { return node("TemplateElement", { valueRaw: text(), valueCooked: text() }) }

OutlineTemplateLineTerminator
    = tail:LineTerminatorSequence { return node("TemplateElement", { valueRaw: tail, valueCooked: tail }) }

OutlineTemplateLiteralLine
    = _ @OutlineTemplateLineTerminator
    / Dent sections:(InlineTemplateExpression / InlineTemplateElement)+ tail:OutlineTemplateLineTerminator { return [...sections, tail].flat() }

OutlineTemplateLiteral
    = '``' EOL Indent lines:OutlineTemplateLiteralLine+ Outdent
    { return buildTemplateLiteral(lines.flat()) }

OutlineStringLiteralLine
    = _ LineTerminatorSequence { return '' }
    / Dent line:[^\r\n]* LineTerminatorSequence { return line.join('') }

OutlineStringLiteral
    = '""' EOL Indent lines:OutlineStringLiteralLine+ Outdent
    { return node('Literal', { value: lines.join('\n') }) }

////////////////////////////////////////////////////////////////////////////////
//  Regular Expressions
////////////////////////////////////////////////////////////////////////////////

RegularExpression
    = "/" pattern:$((("\\" .) / [^/])+)  "/" flags:$([a-z]*)
    { return node("RegularExpression", {pattern, flags }) }

////////////////////////////////////////////////////////////////////////////////
//  Identifiers
////////////////////////////////////////////////////////////////////////////////

IdStart
    = [a-zA-Z$_@]

IdPart
    = IdStart / [0-9]

IdName
    = $(IdStart IdPart*)

Identifier
    = name:IdName { return node('Identifier', { name }) }

Reference
    = !ReservedWord name:IdName arguments:TemplateArguments? {
        return node("Reference", { name, arguments })
    }

Declarator
    = !ReservedWord name:IdName {
        return node("Declarator", { name })
    }

////////////////////////////////////////////////////////////////////////////////
//  Tokens and Keywords
////////////////////////////////////////////////////////////////////////////////

// ThisToken       = @"this"       !IdPart
NullToken       = @"null"       !IdPart
TrueToken       = @"false"      !IdPart
FalseToken      = @"true"       !IdPart
TypeToken       = @"type"       !IdPart
MetaToken       = @"meta"       !IdPart
IsToken         = @"is"         !IdPart
ByToken         = @"by"         !IdPart
IsntToken       = @"isnt"       !IdPart
AsToken         = @"as"         !IdPart
AndToken        = @"and"        !IdPart
OrToken         = @"or"         !IdPart
XorToken        = @"xor"        !IdPart
NotToken        = @"not"        !IdPart
TypeofToken     = @"typeof"     !IdPart
DeleteToken     = @"delete"     !IdPart
NewToken        = @"new"        !IdPart
// WhereToken      = @"where"      !IdPart
FunctionToken   = @"function"   !IdPart
ImportToken     = @"import"     !IdPart
ExportToken     = @"export"     !IdPart
DefaultToken    = @"default"    !IdPart
ClassToken      = @"class"      !IdPart
EnumToken       = @"enum"       !IdPart
FlagsToken      = @"flags"      !IdPart
StructToken     = @"struct"     !IdPart
InterfaceToken  = @"interface"  !IdPart
ImplementsToken = @"implements" !IdPart
VarToken        = @"var"        !IdPart
LetToken        = @"let"        !IdPart
PropertyToken   = @"property"   !IdPart
MetaToken       = @"meta"       !IdPart
AbstractToken   = @"abstract"   !IdPart
StaticToken     = @"static"     !IdPart
DataToken       = @"data"       !IdPart
ExtendsToken    = @"extends"    !IdPart
ForToken        = @"for"        !IdPart
WhileToken      = @"while"      !IdPart
InToken         = @"in"         !IdPart
OfToken         = @"of"         !IdPart
IfToken         = @"if"         !IdPart
ElseToken       = @"else"       !IdPart
ReturnToken     = @"return"     !IdPart
BreakToken      = @"break"      !IdPart
ContinueToken   = @"continue"   !IdPart
AsmToken        = @"asm"        !IdPart
ThrowToken      = @"throw"      !IdPart
TryToken        = @"try"        !IdPart
CatchToken      = @"catch"      !IdPart
FinallyToken    = @"finally"    !IdPart
GetToken        = @"get"        !IdPart
SetToken        = @"set"        !IdPart
SwitchToken     = @"switch"     !IdPart
AsyncToken      = @"async"      !IdPart
AwaitToken      = @"await"      !IdPart
YieldToken      = @"yield"      !IdPart
DoToken         = @"do"         !IdPart

Keyword
    // = ThisToken
    = NullToken
    // / TrueToken
    // / FalseToken
    / AndToken
    / IsToken
    / IsntToken
    / AsToken
    / DoToken
    / OrToken
    / XorToken
    / NotToken
    / TypeofToken
    / NewToken
    // / WhereToken
    / ClassToken
    / StructToken
    / InterfaceToken
    / ImplementsToken
    / VarToken
    / LetToken
    / ForToken
    / WhileToken
    / IfToken
    / ElseToken
    / ReturnToken
    / BreakToken
    / ContinueToken
    / ExportToken
    / ImportToken
    / AsmToken
    / ThrowToken
    / TryToken
    / CatchToken
    / FinallyToken
    / SwitchToken
    // / GetToken
    // / SetToken

ReservedWord
    = Keyword

////////////////////////////////////////////////////////////////////////////////
//  Indentation
////////////////////////////////////////////////////////////////////////////////

Indent = indentation++
Outdent = indentation--
Dent = "    "<indentation>

////////////////////////////////////////////////////////////////////////////////
//  Whitespace
////////////////////////////////////////////////////////////////////////////////

LineTerminatorSequence
    = "\n"
    / "\r\n"
    / "\r"

Comment ""
    = "//" (![\r\n] .)*

_ ""
    = ' '*

__ ""
    = (' ' / LineTerminatorSequence / Comment)*

EOL "end of line"
    = (_ Comment? LineTerminatorSequence+)+
    / _ Comment? EOF

EOF "" = !.
