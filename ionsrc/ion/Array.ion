import
    .Native
    .Map
    .Integer

[Native.JavaScript]: ""
    (function(){
        const emptyArray = Object.freeze([])
        return Object.freeze(Object.assign(function ion_Array(){
            return emptyArray
        }, {
            is(value, ValueType) {
                // TODO: Once calculated on an instance we could cache the result with a unique Symbol.
                if (!Array.isArray(value))
                    return false
                for (let element of value) {
                    if (!ValueType.is(element))
                        return false
                }
                return true
            }
        }))
    })()
export class Array<T> extends Map<Integer where . >= 0, T>
    let length: Integer where >= 0
    # let Index = Integer >= 0 and < length
    # let indexOf: (element: T, from: Index = 0) -> Index | -1
    # let new get: (index: Index) => Value # new version of Map.get that cannot return null, because you know the index is valid
    # let contains: (element: T) => Boolean
    # let count: (element: T) => Integer >= 0 and <= length
    # let counts: Map<T,(Integer >= 0 and <= length)>
    # let reverse: Array<T> .length == length
