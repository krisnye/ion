import
    .Native
    .Map
    .Integer

[Native.JavaScript]: ""
    Object.freeze({
        is(value, ValueType) {
            # TODO: Once calculated on an instance we could cache the result with a unique Symbol.
            if (!Array.isArray(value))
                return false
            for (let value of value.values()) {
                if (!ValueType.is(value))
                    return false
            }
            return true
        }
    })
export class Array<T> extends Map<Integer where . >= 0, T>
    # var length: Integer >= 0
    # let Index = Integer >= 0 and < length
    # let indexOf: (element: T, from: Index = 0) -> Index | -1
    # let new get: (index: Index) => Value # new version of Map.get that cannot return null, because you know the index is valid
    # let contains: (element: T) => Boolean
    # let count: (element: T) => Integer >= 0 and <= length
    # let counts: Map<T,(Integer >= 0 and <= length)>
    # let reverse: Array<T> .length == length
