class NumberType
    precision: 0 | 1 | 2
    min: Number
    max: Number
    minExclusive: Boolean = false
    maxExclusive: Boolean = false

This includes the math to perform +,-,*,/ on NumberType operands

[am,ax] + [bm,bx] = [am+bm,ax+bx]
[am,ax] - [bm,bx] = [am-bm,ax-bx]
[am,ax] * [bm,bx] = [min(am*bm,am*bx,ax*bm,ax*bx),max(am*bm,am*bx,ax*bm,ax*bx)]

[inverse(m,x)] where m>0 | x<0 = [1/x,1/m]
[am,ax] / [bm,bx] = [am,ax] * [inverse(bm,bx)]

[-10,20] / [1,5] = [-10,20] * [inverse(1,5)] = [-10,20] * [1/5,1] = [-10,20]
[-10,20] / [-5,-1] = [-10,20] * [inverse(-5,-1)] = [-10,20] * [-1,-1/5] = [-20,10]

if all are >= or <= then the logic is the same
but what about when values are mixed

For +/- if result minExclusive = max(a.minExclusive,b.minExclusive)
For +/- if result maxExclusive = max(a.maxExclusive,b.maxExclusive)
[am,ax] + [bm,bx] = [am+bm,ax+bx]
am>=<ax + [bm,bx] = [am+bm,ax+bx]
[am,ax] + bm>=<bx = [am+bm,ax+bx]
am>=<ax + bm>=<bx = am+bm>=<ax+bx

Relevant for this:
    https://github.com/triska/clpz
    https://en.wikipedia.org/wiki/Value_range_analysis

Possible format for specifying intervals

< 10
<= 10
> 0
>= 0
0 .. 1
0 .. < 1
> 0 .. 1
> 0 .. < 1

multiple signature types on a function

// defer this as too complicated until later.
add = (a: Interval<Integer>, b: Interval<Integer>): (a.min + b.min) .. (a.max + b.max) -> a + b

//  Let's see if we can accomplish interval math with individual operators

//  interval math
[am,ax] + [bm,bx] = [am+bm,ax+bx]
[am,ax] - [bm,bx] = [am-bm,ax-bx]

(>= am & <= ax) + (>= bm & <= bx)

>= am + >= bm       >= (am + bm)
>= am + <= bx       ?
<= ax + >= bm       ?
<= ax + <= bx       <= (ax + bx)

//  Yes, this works for addition and subtraction

[am,ax] * [bm,bx] = [min(am*bm,am*bx,ax*bm,ax*bx),max(am*bm,am*bx,ax*bm,ax*bx)]

>= am * >= bm       ?
>= am * <= bx       ?
<= ax * >= bm       ?
<= ax * <= bx       ?

//  No, we cannot determine resulting types from decomposed types

//  Conclusion: We need to model Intervals or NumberType's as first class nodes.

[inverse(m,x)] where m>0 | x<0 = [1/x,1/m]
[am,ax] / [bm,bx] = [am,ax] * [inverse(bm,bx)]

//  min/max functions

min([a], [b]) => [min(a1, b1), min(a2, b2)]
max([a], [b]) => [max(a1, b1), max(a2, b2)]

a        a1-------------------a2
b                b1-------b2
